//===-- ProfileTree.h -------------------------------------------------*- C++ -*-===//
//
//                     The KLEE Symbolic Virtual Machine
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//


#include <klee/Expr.h>
#include <klee/util/Mutex.h>
#include "llvm/IR/Instruction.h"
#include <vector>
namespace cliver {
      class SearcherStage;
      class ClientVerifier;
}

namespace klee {
  class ExecutionState;

  class ProfileTree { 
    typedef ExecutionState* data_type;

  public:
    typedef class ProfileTreeNode Node;
    Node *root;

    ProfileTree(const data_type &_root);
    ~ProfileTree();
    
    int post_processing_dfs(ProfileTreeNode *root);
    void consolidate_function_data();
    void dump_branch_clone_graph(std::string path, cliver::ClientVerifier* cv_);
  };

  class ContainerNode{
  public:
    ContainerNode(llvm::Instruction* i);
    virtual ~ContainerNode() = default;
    //The instruction associated with this node's creation.  E.g. branch
    //node would have the branch instruction where this node's execution state
    //was created.  Should only be NULL for root.
    llvm::Instruction* my_instruction;
  };

  class ContainerCallIns: public ContainerNode{
  public:
    ContainerCallIns(llvm::Instruction* i, llvm::Function* target);
    virtual ~ContainerCallIns() = default;
    //function being called.
    llvm::Function* my_target;
    //stores call nodes generated by calls in this->my_target.
    std::vector<ProfileTreeNode*> my_calls;
    //counts the instructions executed in this call to my_target.
    int function_ins_count;
    //counts the instructions executed by my_target's subfunctions
    int function_calls_ins_count;
    //counts the symbolic branches executed in this call to my_target.
    int function_branch_count;
    //counts the symbolic branches executed by my_target's subfunctions
    int function_calls_branch_count;
  };

  class ContainerRetIns: public ContainerNode{
  public:
    ContainerRetIns(llvm::Instruction* i, llvm::Instruction* to);
    virtual ~ContainerRetIns() = default;
    //function being returned to.
    llvm::Instruction* my_return_to;
  };

  class ContainerBranchClone: public ContainerNode{
  public:
    ContainerBranchClone(llvm::Instruction* i, cliver::SearcherStage *s);
    virtual ~ContainerBranchClone() = default;
    //branches/clones immedidiately following this in the graph.
    std::vector<ProfileTreeNode*> my_branches_or_clones;
  };

  class ProfileTreeNode {
    friend class ProfileTree;
    friend class FunctionStatstics;
  public:
    ProfileTreeNode *parent;
    ProfileTreeNode *last_clone;
    std::vector<ProfileTreeNode*> children;
    ContainerNode* container;
    llvm::Instruction* last_instruction;
    cliver::SearcherStage *stage;

    ExecutionState *data;
    void function_call(
        ExecutionState* data,
        llvm::Instruction* ins,
        llvm::Function* target);

    void function_return(
        ExecutionState* data,
        llvm::Instruction* ins,
        llvm::Instruction* to);

    void branch(
        ExecutionState* leftData,
        ExecutionState* rightData,
        llvm::Instruction* ins);

    void clone(
        ExecutionState* me_state,
        ExecutionState* clone_state,
        llvm::Instruction* ins,
        cliver::SearcherStage* stage);
    void increment_ins_count(llvm::Instruction *i);
    void increment_branch_count(void);
    int get_ins_count(void);
    int get_total_ins_count(void);
    int get_total_node_count(void);
    int get_total_clone_count(void);
    int get_total_ret_count(void);
    int get_total_call_count(void);
    int get_total_branch_count(void);
    int get_depth();
    void update_function_statistics(void);
    void update_subtree_count(void);

    enum NodeType { leaf, clone_parent, branch_parent, call_ins, root,
      return_ins };
    enum NodeType get_type(void);
    llvm::Instruction* get_instruction(void);

  protected:
    //leaf: this is the type when a node hasn't split yet.
    //clone_parent: this is the type when a node is split as a result of a clone
    //  call
    //branch_parent: this is the type when a node is split as a result of a branch
    NodeType my_type;
    //Creates a single child node receiving the parent's data.  Used on function call and return.
    ProfileTreeNode* link(
        ExecutionState* data);

    std::pair<ProfileTreeNode*, ProfileTreeNode*> split(
                                 ExecutionState* leftData,
                                 ExecutionState* rightData);

    ProfileTreeNode(ProfileTreeNode *_parent,
                    ExecutionState *_data);
    ~ProfileTreeNode();
    //All the instructions executed by this node's execution state
    int ins_count;
    int my_node_number;
    //Used by most nodes.  Should be a function node, or root node indicating
    //the function executing in.
    ProfileTreeNode* my_function;
    //points to the last branch or clone node
    ProfileTreeNode* my_branch_or_clone;
    //#instructions on a straight line between branches/clones
    int edge_ins_count;
    //the number of instructions executed along the path from the root to this
    //node
    int depth;
    int clone_depth;
    //the number of instructions executed in this instruction's subtree
    int sub_tree_ins_count;

    //All the instructions in the tree
    static int total_ins_count;
    static int total_node_count;
    static int total_branch_count;
    static int total_clone_count;
    static int total_function_call_count;
    static int total_function_ret_count;
  };

  class FunctionStatstics{
    public:
      FunctionStatstics(ContainerCallIns* c);
      ~FunctionStatstics();
      int ins_count;
      int sub_ins_count;
      int branch_count;
      int sub_branch_count;
      int times_called;
      int num_called;
      llvm::Function* function;
      void add(ContainerCallIns* c);
  };
}

