#!/usr/bin/env python

import os
import struct
import sys
from bisect import *
import math

#version_no=3
version_no=4

class KTestError(Exception):
    pass

class KTest:
    @staticmethod
    def fromfile(path):
        if not os.path.exists(path):
            print("ERROR: file %s not found" % (path))
            sys.exit(1)
            
        f = open(path,'rb')
        hdr = f.read(5)
        if len(hdr)!=5 or (hdr!=b'KTEST' and hdr != b"BOUT\n"):
            raise KTestError('unrecognized file')
        version, = struct.unpack('>i', f.read(4))
        if version > version_no:
            raise KTestError('unrecognized version')
        numArgs, = struct.unpack('>i', f.read(4))
        args = []
        for i in range(numArgs):
            size, = struct.unpack('>i', f.read(4))
            args.append(str(f.read(size).decode(encoding='ascii')))
            
        if version >= 2:
            symArgvs, = struct.unpack('>i', f.read(4))
            symArgvLen, = struct.unpack('>i', f.read(4))
        else:
            symArgvs = 0
            symArgvLen = 0

        numObjects, = struct.unpack('>i', f.read(4))
        objects = []

        for i in range(numObjects):
            size, = struct.unpack('>i', f.read(4))
            name = f.read(size)
            tv_sec, = struct.unpack('>q', f.read(8))
            tv_usec, = struct.unpack('>q', f.read(8))
            size, = struct.unpack('>i', f.read(4))
            bytes = f.read(size)
            objects.append( (name,bytes,tv_sec,tv_usec) )

        # Create an instance
        b = KTest(version, args, symArgvs, symArgvLen, objects)
        # Augment with extra filename field
        b.filename = path
        return b

    def __init__(self, version, args, symArgvs, symArgvLen, objects):
        self.version = version
        self.symArgvs = symArgvs
        self.symArgvLen = symArgvLen
        self.args = args
        self.objects = objects

        ## add a field that represents the name of the program used to
        ## generate this .ktest file:
        #program_full_path = self.args[0]
        #program_name = os.path.basename(program_full_path)
        ## sometimes program names end in .bc, so strip them
        #if program_name.endswith('.bc'):
        #  program_name = program_name[:-3]
        #self.programName = program_name

    def tofile(self, path):
        f = open(path, 'wb')
        hdr = 'KTEST'
        f.write(hdr)
        f.write(struct.pack('>i', self.version))
        f.write(struct.pack('>i', len(self.args)))
        for arg in self.args:
            f.write(struct.pack('>i', len(arg)))
            f.write(arg)

        if self.version >= 2:
            f.write(struct.pack('>i', self.symArgvs))
            f.write(struct.pack('>i', self.symArgvLen))

        f.write(struct.pack('>i', len(self.objects)))
        for obj in self.objects:
            obj_name = obj[0]
            obj_bytes = obj[1]
            obj_tv_sec = obj[2]
            obj_tv_usec = obj[3]
            f.write(struct.pack('>i', len(obj_name)))
            f.write(obj_name)
            f.write(struct.pack('>q', obj_tv_sec))
            f.write(struct.pack('>q', obj_tv_usec))
            f.write(struct.pack('>i', len(obj_bytes)))
            f.write(obj_bytes)
        f.close()

    def fix_timestamps(self, csvpath):
        # read reference timestamps extracted from tcpdump
        timestamp_info = read_timestamp_file(csvpath)

        # compute cumulative fractions of bytes for c2s and s2c
        # entries in the ktest file (ignore others)
        total_bytes_self = sum(len(x[1]) for x in self.objects if
                               (x[0] == 'c2s' or x[0] == 's2c'))
        frac_self = []
        current_cum_bytes = 0
        for obj in self.objects:
            frac_self.append(float(current_cum_bytes)/float(total_bytes_self))
            obj_name = obj[0]
            obj_bytes = len(obj[1])
            if obj_name == 'c2s' or obj_name == 's2c':
                current_cum_bytes += obj_bytes

        # adjust timestamps
        for i, obj in enumerate(self.objects):
            obj_name = obj[0]
            obj_frac = frac_self[i]
            new_time = find_closest_time(obj_name, obj_frac, timestamp_info)
            tv_sec, tv_usec = convert_to_timeval(new_time)
            self.objects[i] = (obj[0], obj[1], tv_sec, tv_usec)

def trimZeros(str):
    for i in range(len(str))[::-1]:
        if str[i] != '\x00':
            return str[:i+1]
    return ''

def read_timestamp_file(path):
    """Expected fields in CSV file:
    timestamp,direction,srcIP,srcPort,dstIP,dstPort,packetsize,frac

    Returns: timestamp,direction,packetsize,frac
    """
    time_list = []
    with open(path) as f:
        for line in f:
            fields = line.strip().split(",")
            if fields[0].isalpha(): # skip header
                continue
            timestamp = float(fields[0])
            direction = fields[1]
            packetsize = fields[6]
            frac = float(fields[7])
            time_list.append((timestamp, direction, packetsize, frac))
    return time_list

def find_closest_time(name, frac, timestamp_info):
    if name == 'c2s' or name == 's2c':
        frac_ref = [x[3] for x in timestamp_info if x[1] == name]
        time_ref = [x[0] for x in timestamp_info if x[1] == name]
    else:
        frac_ref = [x[3] for x in timestamp_info]
        time_ref = [x[0] for x in timestamp_info]
    return time_ref[find_nearest_index(frac_ref, frac)]

def find_nearest_index(a, x):
    """
    >>> find_nearest_index(range(1,100,7), 35)
    5
    >>> find_nearest_index(range(1,100,7), 53.4)
    7
    >>> find_nearest_index(range(1,100,7), 10000)
    14
    """
    candidates = []
    le_index = bisect_right(a, x) - 1
    if le_index >= 0:
        candidates.append(le_index)
    ge_index = bisect_left(a, x)
    if ge_index < len(a):
        candidates.append(ge_index)
    if not candidates:
        raise ValueError
    dist_candidates = [(abs(a[c] - x), c) for c in candidates]
    return min(dist_candidates)[1]

def convert_to_timeval(doubletime):
    frac_part, int_part = math.modf(doubletime)
    tv_sec = int(int_part)
    tv_usec = int(math.floor(frac_part * 1000000.0))
    return tv_sec, tv_usec

def main(args):
    from optparse import OptionParser
    op = OptionParser("usage: %prog [options] files")
    op.add_option('','--trim-zeros', dest='trimZeros', action='store_true', 
                  default=False,
                  help='trim trailing zeros')
    op.add_option('','--write-ints', dest='writeInts', action='store_true',
                  default=False,
                  help='convert 4-byte sequences to integers')
    op.add_option('','--skip-data', dest='skipData', action='store_true',
                  default=False,
                  help='Don\'t print data')
    op.add_option('','--one-line', dest='oneLine', action='store_true',
                  default=False,
                  help='print one line summary of each ktest object')
    op.add_option('','--out-file', dest='outFile',
                  help='path to output ktest file')
    op.add_option('','--timestamps', dest='tFile',
                  help='rewrite ktest timestamps using tFile')
    
    opts,args = op.parse_args()
    if not args:
        op.error("incorrect number of arguments")
    if opts.tFile and not opts.outFile:
        op.error("rewriting timestamps requires an output filename")
    if opts.outFile and len(args) != 1:
        op.error("only one input ktest file allowed when output requested")


    for file in args:
        b = KTest.fromfile(file)
        pos = 0
        if not opts.oneLine:
            print('ktest file : %r' % file)
            print('args       : %r' % b.args)
            print('num objects: %r' % len(b.objects))
        delta = 0
        for i,(name,data,tv_sec,tv_usec) in enumerate(b.objects):
            if opts.trimZeros:
                str = trimZeros(data)
            else:
                str = data
            secs = (float)(tv_sec) + ((float)(tv_usec))/1000000
            if delta == 0:
                delta = secs

            if opts.oneLine:
                print('%8d %16r %8d %f' % (i, name, len(data), secs-delta))
            else:
                print('object %4d: name: %r' % (i, name))
                print('object %4d: delta (secs): %f' % (i, secs-delta))
                print('object %4d: size: %r' % (i, len(data)))
                if not opts.skipData:
                    if opts.writeInts and len(data) == 4:
                        print('object %4d: data: %r' % (i, struct.unpack('i',str)[0]))
                    else:
                        print('object %4d: data: %r' % (i, str))
        if file != args[-1]:
            print()
        if opts.tFile:
            b.fix_timestamps(opts.tFile)
        if opts.outFile:
            print('Writing output to %s' % opts.outFile)
            b.tofile(opts.outFile)

if __name__=='__main__':
    main(sys.argv)
