#!/usr/bin/env python

# ===-- ktest-tool --------------------------------------------------------===##
# 
#                      The KLEE Symbolic Virtual Machine
# 
#  This file is distributed under the University of Illinois Open Source
#  License. See LICENSE.TXT for details.
# 
# ===----------------------------------------------------------------------===##

import os
import struct
import sys
from bisect import *
import math
import binascii

#version_no=3
version_no=4

class KTestError(Exception):
    pass

class KTest:
    @staticmethod
    def fromfile(path):
        if not os.path.exists(path):
            print("ERROR: file %s not found" % (path))
            sys.exit(1)
            
        f = open(path,'rb')
        hdr = f.read(5)
        if len(hdr)!=5 or (hdr!=b'KTEST' and hdr != b"BOUT\n"):
            raise KTestError('unrecognized file')
        version, = struct.unpack('>i', f.read(4))
        if version > version_no:
            raise KTestError('unrecognized version')
        print("version: %d" % (version))
        numArgs, = struct.unpack('>i', f.read(4))
        args = []
        for i in range(numArgs):
            size, = struct.unpack('>i', f.read(4))
            args.append(str(f.read(size).decode(encoding='ascii')))
            
        if version >= 2:
            symArgvs, = struct.unpack('>i', f.read(4))
            symArgvLen, = struct.unpack('>i', f.read(4))
        else:
            symArgvs = 0
            symArgvLen = 0

        numObjects, = struct.unpack('>i', f.read(4))
        objects = []

        for i in range(numObjects):
            size, = struct.unpack('>i', f.read(4))
            name = f.read(size)
            if version >= 4:
                tv_sec, = struct.unpack('>q', f.read(8))
                tv_usec, = struct.unpack('>q', f.read(8))
            else:
                tv_sec = 0
                tv_usec = 0
            size, = struct.unpack('>i', f.read(4))
            bytes = f.read(size)
            objects.append( (name,bytes,tv_sec,tv_usec) )

        # Create an instance
        b = KTest(version, args, symArgvs, symArgvLen, objects)
        # Augment with extra filename field
        b.filename = path
        return b

    def __init__(self, version, args, symArgvs, symArgvLen, objects):
        self.version = version
        self.symArgvs = symArgvs
        self.symArgvLen = symArgvLen
        self.args = args
        self.objects = objects

        ## add a field that represents the name of the program used to
        ## generate this .ktest file:
        #program_full_path = self.args[0]
        #program_name = os.path.basename(program_full_path)
        ## sometimes program names end in .bc, so strip them
        #if program_name.endswith('.bc'):
        #  program_name = program_name[:-3]
        #self.programName = program_name

    def tofile(self, path):
        f = open(path, 'wb')
        hdr = 'KTEST'
        f.write(hdr)
        f.write(struct.pack('>i', self.version))
        f.write(struct.pack('>i', len(self.args)))
        for arg in self.args:
            f.write(struct.pack('>i', len(arg)))
            f.write(arg)

        if self.version >= 2:
            f.write(struct.pack('>i', self.symArgvs))
            f.write(struct.pack('>i', self.symArgvLen))

        f.write(struct.pack('>i', len(self.objects)))
        for obj in self.objects:
            obj_name = obj[0]
            obj_bytes = obj[1]
            obj_tv_sec = obj[2]
            obj_tv_usec = obj[3]
            f.write(struct.pack('>i', len(obj_name)))
            f.write(obj_name)
            f.write(struct.pack('>q', obj_tv_sec))
            f.write(struct.pack('>q', obj_tv_usec))
            f.write(struct.pack('>i', len(obj_bytes)))
            f.write(obj_bytes)
        f.close()

    def totextfile(self, path, sessionID, appendFIN):
        """Write text file of the form:
        Timestamp SessionID Direction NumBytes Data(Hex)  Comments
        98.123456        14 s2c       5        1703030024 # TLS Application Data

        Note that instead of simply 'Direction', we can also save
        arbitrary types such as stdin, rng, etc. This function does
        not insert any comments.
        """
        f = open(path, 'w')

        network_activity = False
        for obj in self.objects:
            obj_name = obj[0]
            obj_bytes = obj[1]
            obj_tv_sec = obj[2]
            obj_tv_usec = obj[3]
            timestamp = str(obj_tv_sec) + ".%6.6d" % (obj_tv_usec)
            session_str = str(sessionID)
            numbytes = str(len(obj_bytes))
            data_str = binascii.hexlify(obj_bytes).upper()
            line = "  ".join([timestamp, session_str, obj_name,
                             numbytes, data_str])
            print >>f, line
            # save last network activity
            if obj_name == "c2s" or obj_name == "s2c":
                network_activity = True
                network_last_timestamp = timestamp

        # Optionally append 0-length packets representing TCP FINs
        if network_activity and appendFIN:
            timestamp = network_last_timestamp
            session_str = str(sessionID)
            numbytes = str(0)
            for direction in ["c2s", "s2c"]:
                line = "  ".join([timestamp, session_str, direction, numbytes])
                print >>f, line

        f.close()

    def add_ndss2013_timestamps(self, csvpath):
        # update version number
        self.version = version_no

        # read timestamps output by client
        timestamp_info = read_ndss2013_timestamp_file(csvpath)
        # adjust timestamps
        for i, obj in enumerate(self.objects):
            obj_name = obj[0]
            ts_obj_name = timestamp_info[i][1]
            assert (obj_name == ts_obj_name), "mismatch line %d: %s %s" % (i, obj_name, ts_obj_name)
            #obj_sz = len(obj[1])
            #ts_obj_sz = timestamp_info[i][2]
            #assert (obj_sz == ts_obj_sz), "mismatch line %d: %d %d" % (i, obj_sz, ts_obj_sz)
            tv_sec, tv_usec = convert_to_timeval(timestamp_info[i][0])
            self.objects[i] = (obj[0], obj[1], tv_sec, tv_usec)


    def fix_timestamps(self, csvpath):
        # read reference timestamps extracted from tcpdump
        timestamp_info = read_timestamp_file(csvpath)

        # compute cumulative fractions of bytes for c2s and s2c
        # entries in the ktest file (ignore others)
        total_bytes_self = sum(len(x[1]) for x in self.objects if
                               (x[0] == 'c2s' or x[0] == 's2c'))
        frac_self = []
        current_cum_bytes = 0
        for obj in self.objects:
            frac_self.append(float(current_cum_bytes)/float(total_bytes_self))
            obj_name = obj[0]
            obj_bytes = len(obj[1])
            if obj_name == 'c2s' or obj_name == 's2c':
                current_cum_bytes += obj_bytes

        # adjust timestamps
        for i, obj in enumerate(self.objects):
            obj_name = obj[0]
            obj_frac = frac_self[i]
            new_time = find_closest_time(obj_name, obj_frac, timestamp_info)
            tv_sec, tv_usec = convert_to_timeval(new_time)
            self.objects[i] = (obj[0], obj[1], tv_sec, tv_usec)

def trimZeros(str):
    for i in range(len(str))[::-1]:
        if str[i] != '\x00':
            return str[:i+1]
    return ''

def read_timestamp_file(path):
    """Expected fields in CSV file:
    timestamp,direction,srcIP,srcPort,dstIP,dstPort,packetsize,frac

    Returns: timestamp,direction,packetsize,frac
    """
    time_list = []
    with open(path) as f:
        for line in f:
            fields = line.strip().split(",")
            if fields[0].isalpha(): # skip header
                continue
            timestamp = float(fields[0])
            direction = fields[1]
            packetsize = fields[6]
            frac = float(fields[7])
            time_list.append((timestamp, direction, packetsize, frac))
    return time_list

def read_ndss2013_timestamp_file(path):
    """Expected fields in file:
    MSGINFO timestamp direction len1 len2

    Returns: timestamp,direction,len1,len2
    """
    time_list = []
    with open(path) as f:
        for line in f:
            fields = line.strip().split(" ")
            timestamp = float(fields[1])
            direction = fields[2]
            len1 = int(fields[3])
            len2 = int(fields[4])
            time_list.append((timestamp, direction, len1, len2))
    return time_list


def find_closest_time(name, frac, timestamp_info):
    if name == 'c2s' or name == 's2c':
        frac_ref = [x[3] for x in timestamp_info if x[1] == name]
        time_ref = [x[0] for x in timestamp_info if x[1] == name]
    else:
        frac_ref = [x[3] for x in timestamp_info]
        time_ref = [x[0] for x in timestamp_info]
    return time_ref[find_nearest_index(frac_ref, frac)]

def find_nearest_index(a, x):
    """
    >>> find_nearest_index(range(1,100,7), 35)
    5
    >>> find_nearest_index(range(1,100,7), 53.4)
    7
    >>> find_nearest_index(range(1,100,7), 10000)
    14
    """
    candidates = []
    le_index = bisect_right(a, x) - 1
    if le_index >= 0:
        candidates.append(le_index)
    ge_index = bisect_left(a, x)
    if ge_index < len(a):
        candidates.append(ge_index)
    if not candidates:
        raise ValueError
    dist_candidates = [(abs(a[c] - x), c) for c in candidates]
    return min(dist_candidates)[1]

def convert_to_timeval(doubletime):
    frac_part, int_part = math.modf(doubletime)
    tv_sec = int(int_part)
    tv_usec = int(math.floor(frac_part * 1000000.0))
    return tv_sec, tv_usec

def write_tls_key(tls_master_secret, filename):
    MASTER_SECRET_LENGTH = 48
    if tls_master_secret is None:
        print >>sys.stderr, "TLS master secret not present in ktest file"
        sys.exit(2)
    elif len(tls_master_secret) != MASTER_SECRET_LENGTH:
        print >>sys.stderr, \
            "Invalid master secret length (got %d, expected %d)" % \
            (len(tls_master_secret), MASTER_SECRET_LENGTH)
        sys.exit(2)
    with open(filename, 'wb') as f:
        f.write(tls_master_secret)
    print('TLS master secret written to %s' % filename)

def main(args):
    from optparse import OptionParser
    op = OptionParser("usage: %prog [options] files")
    op.add_option('','--trim-zeros', dest='trimZeros', action='store_true', 
                  default=False,
                  help='trim trailing zeros')
    op.add_option('','--write-ints', dest='writeInts', action='store_true',
                  default=False,
                  help='convert 4-byte sequences to integers')
    op.add_option('','--skip-data', dest='skipData', action='store_true',
                  default=False,
                  help='Don\'t print data')
    op.add_option('','--one-line', dest='oneLine', action='store_true',
                  default=False,
                  help='print one line summary of each ktest object')
    op.add_option('','--out-file', dest='outFile',
                  help='path to output ktest file')
    op.add_option('','--text-format', dest='textFormat', action='store_true',
                  default=False,
                  help='output file should be KTestText format (*.ktest.txt)')
    op.add_option('','--session-id', dest='sID', default="0",
                  help='set KTestText SessionID (default=0)')
    op.add_option('','--add-tcp-fin', dest='addTCPFIN', action='store_true',
                  default=False,
                  help='KTestText: append 0-length c2s and s2c (TCP FINs)')
    op.add_option('','--tls-key', dest='tlsKeyFile',
                  help='write TLS master secret to file')
    op.add_option('','--timestamps', dest='tFile',
                  help='rewrite ktest timestamps using tFile')
    op.add_option('','--ndss2013timestamps', dest='tFileNDSS',
                  help='rewrite ktest timestamps using tFile from NDSS2013 ')
    
    opts,args = op.parse_args()
    if not args:
        op.error("incorrect number of arguments")
    if opts.tFile and not opts.outFile:
        op.error("rewriting timestamps requires an output filename")
    if opts.outFile and len(args) != 1:
        op.error("only one input ktest file allowed when output requested")
    if opts.tlsKeyFile and len(args) != 1:
        op.error("exactly one input ktest file allowed for TLS key extraction")
    if opts.textFormat and not opts.outFile:
        op.error("KTestText mode requires an output filename")
    if opts.addTCPFIN and not opts.textFormat:
        op.error("appending TCP FIN packets currently requires KTestText mode")

    session_id = int(opts.sID)

    if opts.tlsKeyFile:
        tls_master_secret = None

    for file in args:
        b = KTest.fromfile(file)
        pos = 0
        if not opts.oneLine:
            print('ktest file : %r' % file)
            print('args       : %r' % b.args)
            print('num objects: %r' % len(b.objects))
        delta = 0
        if opts.tFileNDSS:
            b.add_ndss2013_timestamps(opts.tFileNDSS)
        for i,(name,data,tv_sec,tv_usec) in enumerate(b.objects):
            if opts.trimZeros:
                str = trimZeros(data)
            else:
                str = data
            secs = (float)(tv_sec) + ((float)(tv_usec))/1000000
            if delta == 0:
                delta = secs

            if opts.oneLine:
                print('%8d %16r %8d %f' % (i, name, len(data), secs-delta))
            else:
                print('object %4d: name: %r' % (i, name))
                print('object %4d: delta (secs): %f' % (i, secs-delta))
                print('object %4d: size: %r' % (i, len(data)))
                if not opts.skipData:
                    if opts.writeInts and len(data) == 4:
                        print('object %4d: data: %r' % (i, struct.unpack('i',str)[0]))
                    else:
                        print('object %4d: data: %r' % (i, str))

            if opts.tlsKeyFile and name == 'master_secret':
                tls_master_secret = data

        if file != args[-1]:
            print()
        if opts.tFile:
            b.fix_timestamps(opts.tFile)
        if opts.outFile:
            if opts.textFormat:
                print('Writing KTestText output to %s' % opts.outFile)
                b.totextfile(opts.outFile, session_id, opts.addTCPFIN)
            else:
                print('Writing output to %s' % opts.outFile)
                b.tofile(opts.outFile)
        if opts.tlsKeyFile:
            write_tls_key(tls_master_secret, opts.tlsKeyFile)

if __name__=='__main__':
    main(sys.argv)
